# Session API Reference

Technical reference for session management data structures and repository API.

## Overview

The session management system provides persistence for workflow execution state through Pydantic models and repository abstractions. Session persistence enables crash recovery, workflow resume, and cost optimization by skipping completed work.

**Module:** `strands_cli.session`

**Key Features:**
- Automatic checkpointing after each step/task/branch completion
- Agent conversation history restoration via Strands SDK FileSessionManager
- Token usage tracking across resume sessions
- Spec change detection with SHA256 hash validation
- Pattern-specific execution state serialization

---

## Data Models

### SessionStatus

Enumeration of session execution states.

**Location:** `src/strands_cli/session/__init__.py`

```python
class SessionStatus(str, Enum):
    """Session execution status."""
    RUNNING = "running"      # Workflow currently executing
    PAUSED = "paused"        # Workflow paused (future: Phase 12 HITL)
    COMPLETED = "completed"  # Workflow finished successfully
    FAILED = "failed"        # Workflow terminated with error
```

**Usage:**
```python
from strands_cli.session import SessionStatus

if state.metadata.status == SessionStatus.COMPLETED:
    print("Already finished")
```

---

### SessionMetadata

Core session metadata and lifecycle information.

**Location:** `src/strands_cli/session/__init__.py`

```python
class SessionMetadata(BaseModel):
    """Core session metadata."""
    session_id: str              # UUID (generated by generate_session_id())
    workflow_name: str           # From spec.name
    spec_hash: str               # SHA256 of original spec file
    pattern_type: str            # PatternType enum value (e.g., "chain")
    status: SessionStatus        # Current execution status
    created_at: str              # ISO 8601 timestamp
    updated_at: str              # ISO 8601 timestamp (updated on checkpoint)
    error: str | None = None     # Error message if status == FAILED
```

**Example:**
```python
from strands_cli.session import SessionMetadata, SessionStatus
from strands_cli.session.utils import generate_session_id, now_iso8601

metadata = SessionMetadata(
    session_id=generate_session_id(),
    workflow_name="research-chain",
    spec_hash="abc123def456...",
    pattern_type="chain",
    status=SessionStatus.RUNNING,
    created_at=now_iso8601(),
    updated_at=now_iso8601(),
)
```

---

### TokenUsage

Token usage tracking for cost analysis.

**Location:** `src/strands_cli/session/__init__.py`

```python
class TokenUsage(BaseModel):
    """Token usage tracking."""
    total_input_tokens: int = 0         # Cumulative input tokens
    total_output_tokens: int = 0        # Cumulative output tokens
    by_agent: dict[str, int] = Field(   # Per-agent token breakdown
        default_factory=dict
    )
```

**Example:**
```python
from strands_cli.session import TokenUsage

usage = TokenUsage(
    total_input_tokens=3000,
    total_output_tokens=2000,
    by_agent={
        "researcher": 2000,
        "analyst": 3000
    }
)

print(f"Total tokens: {usage.total_input_tokens + usage.total_output_tokens}")
```

---

### SessionState

Complete session state for persistence.

**Location:** `src/strands_cli/session/__init__.py`

```python
class SessionState(BaseModel):
    """Complete session state for persistence."""
    metadata: SessionMetadata                   # Session metadata
    variables: dict[str, str]                   # User-provided variables (--var)
    runtime_config: dict[str, Any]              # Runtime configuration (provider, model_id, etc.)
    pattern_state: dict[str, Any]               # Pattern-specific execution state
    token_usage: TokenUsage                     # Token usage tracking
    artifacts_written: list[str] = Field(       # Artifacts already written
        default_factory=list
    )
```

**Pattern State Structures:**

**Chain:**
```python
pattern_state = {
    "current_step": 2,          # Next step to execute (0-indexed)
    "step_history": [
        {
            "index": 0,
            "agent": "researcher",
            "response": "Research findings...",
            "tokens_estimated": 2000
        },
        {
            "index": 1,
            "agent": "analyst",
            "response": "Analysis...",
            "tokens_estimated": 3000
        }
    ]
}
```

**Workflow (Phase 3):**
```python
pattern_state = {
    "completed_tasks": ["task1", "task2"],
    "pending_tasks": ["task3"],
    "blocked_tasks": ["task4"],  # Waiting on dependencies
    "task_outputs": {
        "task1": {"response": "...", "tokens": 1000},
        "task2": {"response": "...", "tokens": 1200}
    }
}
```

**Example:**
```python
from strands_cli.session import SessionState, SessionMetadata, SessionStatus, TokenUsage
from strands_cli.session.utils import generate_session_id, now_iso8601

state = SessionState(
    metadata=SessionMetadata(
        session_id=generate_session_id(),
        workflow_name="research-chain",
        spec_hash="abc123",
        pattern_type="chain",
        status=SessionStatus.RUNNING,
        created_at=now_iso8601(),
        updated_at=now_iso8601()
    ),
    variables={"topic": "AI agents", "format": "markdown"},
    runtime_config={
        "provider": "ollama",
        "model_id": "llama2",
        "host": "http://localhost:11434"
    },
    pattern_state={
        "current_step": 2,
        "step_history": [...]
    },
    token_usage=TokenUsage(
        total_input_tokens=3000,
        total_output_tokens=2000
    ),
    artifacts_written=["./output/step1.md"]
)
```

---

## Repository API

### FileSessionRepository

File-based session persistence using local filesystem.

**Location:** `src/strands_cli/session/file_repository.py`

```python
class FileSessionRepository:
    """File-based session storage using local filesystem.

    Storage structure:
        {storage_dir}/session_{session_id}/
        ├── session.json
        ├── pattern_state.json
        ├── spec_snapshot.yaml
        └── agents/  # Managed by Strands SDK FileSessionManager
    """
```

#### Constructor

```python
def __init__(self, storage_dir: Path | None = None):
    """Initialize repository with storage directory.

    Args:
        storage_dir: Base directory for sessions (default: ~/.strands/sessions)
    """
```

**Example:**
```python
from strands_cli.session.file_repository import FileSessionRepository

# Use default directory (~/.strands/sessions)
repo = FileSessionRepository()

# Use custom directory
repo = FileSessionRepository(storage_dir=Path("/tmp/sessions"))
```

#### Methods

##### exists()

```python
def exists(self, session_id: str) -> bool:
    """Check if session exists.

    Args:
        session_id: Session ID to check

    Returns:
        True if session directory exists, False otherwise
    """
```

**Example:**
```python
if repo.exists("abc123"):
    print("Session found")
```

---

##### save()

```python
def save(self, state: SessionState, spec_content: str) -> None:
    """Save complete session state.

    Args:
        state: Session state to persist
        spec_content: Original workflow spec YAML/JSON content

    Side Effects:
        Creates session directory if not exists
        Writes session.json, pattern_state.json, spec_snapshot.yaml
        Logs "session_saved" event
    """
```

**Example:**
```python
from strands_cli.session import SessionState
from pathlib import Path

state = SessionState(...)
spec_content = Path("workflow.yaml").read_text()

repo.save(state, spec_content)
# Session saved to ~/.strands/sessions/session_<uuid>/
```

---

##### load()

```python
def load(self, session_id: str) -> SessionState | None:
    """Load session state from disk.

    Args:
        session_id: Session ID to load

    Returns:
        SessionState if found, None otherwise

    Logs:
        "session_loaded" event if successful
        "session_not_found" warning if missing
    """
```

**Example:**
```python
state = repo.load("abc123-def456-...")
if state:
    print(f"Loaded session: {state.metadata.workflow_name}")
else:
    print("Session not found")
```

---

##### delete()

```python
def delete(self, session_id: str) -> None:
    """Delete session completely.

    Args:
        session_id: Session ID to delete

    Side Effects:
        Removes entire session directory (session.json, agents/, etc.)
        Logs "session_deleted" event
        No-op if session doesn't exist
    """
```

**Example:**
```python
repo.delete("abc123-def456-...")
# Session directory removed
```

---

##### list_sessions()

```python
def list_sessions(self) -> list[SessionMetadata]:
    """List all sessions in storage.

    Returns:
        List of session metadata objects (one per session)

    Note:
        Only returns sessions with valid session.json files
        Corrupt sessions are skipped silently
    """
```

**Example:**
```python
sessions = repo.list_sessions()
for session in sessions:
    print(f"{session.session_id}: {session.workflow_name} ({session.status})")
```

---

##### get_agents_dir()

```python
def get_agents_dir(self, session_id: str) -> Path:
    """Get agents directory for Strands SDK FileSessionManager.

    Args:
        session_id: Session ID

    Returns:
        Path to agents directory (may not exist yet)

    Usage:
        Used by AgentCache to configure Strands SDK session manager
    """
```

**Example:**
```python
from strands.session.file_session_manager import FileSessionManager

agents_dir = repo.get_agents_dir("abc123")
session_manager = FileSessionManager(
    session_id="abc123_researcher",
    storage_dir=str(agents_dir)
)
```

---

## Utility Functions

### generate_session_id()

Generate unique session identifier.

**Location:** `src/strands_cli/session/utils.py`

```python
def generate_session_id() -> str:
    """Generate unique session ID.

    Returns:
        UUID4 string (e.g., "a1b2c3d4-e5f6-7890-abcd-ef1234567890")
    """
```

**Example:**
```python
from strands_cli.session.utils import generate_session_id

session_id = generate_session_id()
print(session_id)  # "f47ac10b-58cc-4372-a567-0e02b2c3d479"
```

---

### compute_spec_hash()

Compute SHA256 hash of workflow spec file.

**Location:** `src/strands_cli/session/utils.py`

```python
def compute_spec_hash(spec_path: Path) -> str:
    """Compute SHA256 hash of workflow spec.

    Args:
        spec_path: Path to workflow spec file

    Returns:
        Hex-encoded SHA256 hash (64 characters)

    Use Case:
        Detect spec file changes between session creation and resume
    """
```

**Example:**
```python
from strands_cli.session.utils import compute_spec_hash
from pathlib import Path

spec_hash = compute_spec_hash(Path("workflow.yaml"))
print(spec_hash)  # "abc123def456..."

# Later, check if spec changed
current_hash = compute_spec_hash(Path("workflow.yaml"))
if current_hash != spec_hash:
    print("Spec file has changed!")
```

---

### now_iso8601()

Get current timestamp in ISO 8601 format.

**Location:** `src/strands_cli/session/utils.py`

```python
def now_iso8601() -> str:
    """Get current timestamp in ISO 8601 format.

    Returns:
        ISO 8601 timestamp string (UTC timezone)
        Example: "2025-11-09T10:15:30.123456+00:00"
    """
```

**Example:**
```python
from strands_cli.session.utils import now_iso8601

timestamp = now_iso8601()
print(timestamp)  # "2025-11-09T14:30:45.678901+00:00"

# Use in session metadata
metadata = SessionMetadata(
    created_at=now_iso8601(),
    updated_at=now_iso8601(),
    # ...
)
```

---

## Integration Patterns

### Creating a New Session

```python
from strands_cli.session import SessionState, SessionMetadata, SessionStatus, TokenUsage
from strands_cli.session.file_repository import FileSessionRepository
from strands_cli.session.utils import generate_session_id, compute_spec_hash, now_iso8601
from pathlib import Path

# 1. Generate session ID
session_id = generate_session_id()

# 2. Compute spec hash
spec_path = Path("workflow.yaml")
spec_hash = compute_spec_hash(spec_path)

# 3. Create session state
state = SessionState(
    metadata=SessionMetadata(
        session_id=session_id,
        workflow_name="my-workflow",
        spec_hash=spec_hash,
        pattern_type="chain",
        status=SessionStatus.RUNNING,
        created_at=now_iso8601(),
        updated_at=now_iso8601()
    ),
    variables={"topic": "AI"},
    runtime_config={"provider": "ollama", "model_id": "llama2"},
    pattern_state={"current_step": 0, "step_history": []},
    token_usage=TokenUsage()
)

# 4. Save to repository
repo = FileSessionRepository()
spec_content = spec_path.read_text()
repo.save(state, spec_content)

print(f"Session created: {session_id}")
```

---

### Checkpointing During Execution

```python
# Inside executor (e.g., run_chain)
if session_repo and session_state:
    # Update pattern state
    session_state.pattern_state["current_step"] = step_index + 1
    session_state.pattern_state["step_history"].append(step_result)

    # Update token usage
    session_state.token_usage.total_input_tokens += input_tokens
    session_state.token_usage.total_output_tokens += output_tokens
    session_state.token_usage.by_agent[agent_id] = (
        session_state.token_usage.by_agent.get(agent_id, 0) + total_tokens
    )

    # Update metadata
    session_state.metadata.updated_at = now_iso8601()

    # Save checkpoint
    spec_content = (
        session_repo._session_dir(session_state.metadata.session_id) 
        / "spec_snapshot.yaml"
    ).read_text()
    session_repo.save(session_state, spec_content)

    logger.debug("checkpoint_saved", step=step_index+1)
```

---

### Loading and Resuming

```python
from strands_cli.session.file_repository import FileSessionRepository
from strands_cli.session import SessionStatus
from strands_cli.loader import load_spec

# 1. Load session
repo = FileSessionRepository()
state = repo.load("abc123-def456-...")

if not state:
    raise ValueError("Session not found")

if state.metadata.status == SessionStatus.COMPLETED:
    raise ValueError("Session already completed")

# 2. Load spec from snapshot
spec_path = repo._session_dir(state.metadata.session_id) / "spec_snapshot.yaml"
spec = load_spec(spec_path, state.variables)

# 3. Validate spec hash
from strands_cli.session.utils import compute_spec_hash
current_hash = compute_spec_hash(spec_path)
if current_hash != state.metadata.spec_hash:
    logger.warning("spec_changed", original=state.metadata.spec_hash, current=current_hash)

# 4. Resume execution
result = await run_chain(spec, state.variables, session_state=state, session_repo=repo)
```

---

## Session Directory Layout

```
~/.strands/sessions/session_a1b2c3d4-e5f6-7890-abcd-ef1234567890/
├── session.json              # SessionMetadata + variables + runtime + token_usage + artifacts
├── pattern_state.json        # Pattern-specific state (current_step, step_history, etc.)
├── spec_snapshot.yaml        # Original workflow spec for hash validation
└── agents/                   # Strands SDK agent sessions
    ├── researcher/
    │   ├── agent.json        # Agent state (key-value store)
    │   └── messages/
    │       ├── message_0.json
    │       └── message_1.json
    └── analyst/
        └── ...
```

### session.json Format

```json
{
  "metadata": {
    "session_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "workflow_name": "research-chain",
    "spec_hash": "abc123def456...",
    "pattern_type": "chain",
    "status": "running",
    "created_at": "2025-11-09T10:00:00Z",
    "updated_at": "2025-11-09T10:15:00Z",
    "error": null
  },
  "variables": {
    "topic": "AI agents",
    "format": "markdown"
  },
  "runtime_config": {
    "provider": "ollama",
    "model_id": "llama2",
    "host": "http://localhost:11434"
  },
  "token_usage": {
    "total_input_tokens": 3000,
    "total_output_tokens": 2000,
    "by_agent": {
      "researcher": 2000,
      "analyst": 3000
    }
  },
  "artifacts_written": [
    "./output/step1.md",
    "./output/step2.json"
  ]
}
```

### pattern_state.json Format (Chain)

```json
{
  "current_step": 2,
  "step_history": [
    {
      "index": 0,
      "agent": "researcher",
      "response": "Research findings about AI agents...",
      "tokens_estimated": 2000
    },
    {
      "index": 1,
      "agent": "analyst",
      "response": "Analysis of research findings...",
      "tokens_estimated": 3000
    }
  ]
}
```

---

## Testing Patterns

### Unit Test Example

```python
import pytest
from pathlib import Path
from strands_cli.session import SessionState, SessionMetadata, SessionStatus, TokenUsage
from strands_cli.session.file_repository import FileSessionRepository
from strands_cli.session.utils import generate_session_id

def test_save_and_load_session(tmp_path):
    """Test saving and loading a session."""
    repo = FileSessionRepository(storage_dir=tmp_path)
    session_id = generate_session_id()

    # Create session state
    state = SessionState(
        metadata=SessionMetadata(
            session_id=session_id,
            workflow_name="test-workflow",
            spec_hash="abc123",
            pattern_type="chain",
            status=SessionStatus.RUNNING,
            created_at="2025-11-09T10:00:00Z",
            updated_at="2025-11-09T10:00:00Z"
        ),
        variables={"topic": "AI"},
        runtime_config={"provider": "ollama"},
        pattern_state={"current_step": 1, "step_history": []},
        token_usage=TokenUsage(total_input_tokens=100, total_output_tokens=50)
    )

    # Save
    repo.save(state, "version: 0\nname: test")

    # Load
    loaded = repo.load(session_id)
    assert loaded is not None
    assert loaded.metadata.session_id == session_id
    assert loaded.variables["topic"] == "AI"
    assert loaded.pattern_state["current_step"] == 1
```

---

## Related Documentation

- [Session Management Guide](../howto/session-management.md) - User-facing session management
- [DURABLE.md](../../DURABLE.md) - Complete session architecture and roadmap
- [Chain Executor](../../src/strands_cli/exec/chain.py) - Chain pattern checkpointing implementation
- [Workflow Manual](./workflow-manual.md) - Workflow spec reference
